   1               		.file	"example.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.send_str,"ax",@progbits
  11               	.global	send_str
  13               	send_str:
  14               	.LVL0:
  15               	.LFB8:
  16               		.file 1 "example.c"
   1:example.c     **** /* Simple example for Teensy USB Development Board
   2:example.c     ****  * http://www.pjrc.com/teensy/
   3:example.c     ****  * Copyright (c) 2008 PJRC.COM, LLC
   4:example.c     ****  * 
   5:example.c     ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:example.c     ****  * of this software and associated documentation files (the "Software"), to deal
   7:example.c     ****  * in the Software without restriction, including without limitation the rights
   8:example.c     ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:example.c     ****  * copies of the Software, and to permit persons to whom the Software is
  10:example.c     ****  * furnished to do so, subject to the following conditions:
  11:example.c     ****  * 
  12:example.c     ****  * The above copyright notice and this permission notice shall be included in
  13:example.c     ****  * all copies or substantial portions of the Software.
  14:example.c     ****  * 
  15:example.c     ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:example.c     ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:example.c     ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:example.c     ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:example.c     ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:example.c     ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:example.c     ****  * THE SOFTWARE.
  22:example.c     ****  */
  23:example.c     **** 
  24:example.c     **** #include <avr/io.h>
  25:example.c     **** #include <avr/pgmspace.h>
  26:example.c     **** #include <stdint.h>
  27:example.c     **** #include <util/delay.h>
  28:example.c     **** #include "usb_serial.h"
  29:example.c     **** 
  30:example.c     **** #define LED_CONFIG	(DDRD |= (1<<6))
  31:example.c     **** #define LED_ON		(PORTD |= (1<<6))
  32:example.c     **** #define LED_OFF		(PORTD &= ~(1<<6))
  33:example.c     **** #define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))
  34:example.c     **** 
  35:example.c     **** void send_str(const char *s);
  36:example.c     **** uint8_t recv_str(char *buf, uint8_t size);
  37:example.c     **** void parse_and_execute_command(const char *buf, uint8_t num);
  38:example.c     **** 
  39:example.c     **** #if 0
  40:example.c     **** // Very simple character echo test
  41:example.c     **** int main(void)
  42:example.c     **** {
  43:example.c     **** 	CPU_PRESCALE(0);
  44:example.c     **** 	usb_init();
  45:example.c     **** 	while (1) {
  46:example.c     **** 		int n = usb_serial_getchar();
  47:example.c     **** 		if (n >= 0) usb_serial_putchar(n);
  48:example.c     **** 	}
  49:example.c     **** }
  50:example.c     **** 
  51:example.c     **** #else
  52:example.c     **** 
  53:example.c     **** // Basic command interpreter for controlling port pins
  54:example.c     **** int main(void)
  55:example.c     **** {
  56:example.c     **** 	char buf[32];
  57:example.c     **** 	uint8_t n;
  58:example.c     **** 
  59:example.c     **** 	// set for 16 MHz clock, and turn on the LED
  60:example.c     **** 	CPU_PRESCALE(0);
  61:example.c     **** 	LED_CONFIG;
  62:example.c     **** 	LED_ON;
  63:example.c     **** 
  64:example.c     **** 	// initialize the USB, and then wait for the host
  65:example.c     **** 	// to set configuration.  If the Teensy is powered
  66:example.c     **** 	// without a PC connected to the USB port, this 
  67:example.c     **** 	// will wait forever.
  68:example.c     **** 	usb_init();
  69:example.c     **** 	while (!usb_configured()) /* wait */ ;
  70:example.c     **** 	_delay_ms(1000);
  71:example.c     **** 
  72:example.c     **** 	while (1) {
  73:example.c     **** 		// wait for the user to run their terminal emulator program
  74:example.c     **** 		// which sets DTR to indicate it is ready to receive.
  75:example.c     **** 		while (!(usb_serial_get_control() & USB_SERIAL_DTR)) /* wait */ ;
  76:example.c     **** 
  77:example.c     **** 		// discard anything that was received prior.  Sometimes the
  78:example.c     **** 		// operating system or other software will send a modem
  79:example.c     **** 		// "AT command", which can still be buffered.
  80:example.c     **** 		usb_serial_flush_input();
  81:example.c     **** 
  82:example.c     **** 		// print a nice welcome message
  83:example.c     **** 		send_str(PSTR("\r\nTeensy USB Serial Example, "
  84:example.c     **** 			"Simple Pin Control Shell\r\n\r\n"
  85:example.c     **** 			"Example Commands\r\n"
  86:example.c     **** 			"  B0?   Read Port B, pin 0\r\n"
  87:example.c     **** 			"  C2=0  Write Port C, pin 1 LOW\r\n"
  88:example.c     **** 			"  D6=1  Write Port D, pin 6 HIGH  (D6 is LED pin)\r\n\r\n"));
  89:example.c     **** 
  90:example.c     **** 		// and then listen for commands and process them
  91:example.c     **** 		while (1) {
  92:example.c     **** 			send_str(PSTR("> "));
  93:example.c     **** 			n = recv_str(buf, sizeof(buf));
  94:example.c     **** 			if (n == 255) break;
  95:example.c     **** 			send_str(PSTR("\r\n"));
  96:example.c     **** 			parse_and_execute_command(buf, n);
  97:example.c     **** 		}
  98:example.c     **** 	}
  99:example.c     **** }
 100:example.c     **** #endif
 101:example.c     **** 
 102:example.c     **** // Send a string to the USB serial port.  The string must be in
 103:example.c     **** // flash memory, using PSTR
 104:example.c     **** //
 105:example.c     **** void send_str(const char *s)
 106:example.c     **** {
  17               		.loc 1 106 1 view -0
  18               		.cfi_startproc
  19               		.loc 1 106 1 is_stmt 0 view .LVU1
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 EC01      		movw r28,r24
  33               	.LVL1:
  34               	.L3:
 107:example.c     **** 	char c;
  35               		.loc 1 107 2 is_stmt 1 view .LVU2
 108:example.c     **** 	while (1) {
  36               		.loc 1 108 2 view .LVU3
 109:example.c     **** 		c = pgm_read_byte(s++);
  37               		.loc 1 109 3 view .LVU4
  38               	.LBB7:
  39               		.loc 1 109 7 view .LVU5
  40               		.loc 1 109 7 view .LVU6
  41               		.loc 1 109 7 view .LVU7
  42 0006 FE01      		movw r30,r28
  43               	/* #APP */
  44               	 ;  109 "example.c" 1
  45 0008 8491      		lpm r24, Z
  46               		
  47               	 ;  0 "" 2
  48               	.LVL2:
  49               		.loc 1 109 7 view .LVU8
  50               		.loc 1 109 7 is_stmt 0 view .LVU9
  51               	/* #NOAPP */
  52               	.LBE7:
 110:example.c     **** 		if (!c) break;
  53               		.loc 1 110 3 is_stmt 1 view .LVU10
  54 000a 2196      		adiw r28,1
  55               	.LVL3:
  56               		.loc 1 110 6 is_stmt 0 view .LVU11
  57 000c 8823      		tst r24
  58 000e 01F0      		breq .L1
 111:example.c     **** 		usb_serial_putchar(c);
  59               		.loc 1 111 3 is_stmt 1 view .LVU12
  60 0010 0E94 0000 		call usb_serial_putchar
  61               	.LVL4:
 108:example.c     **** 		c = pgm_read_byte(s++);
  62               		.loc 1 108 8 view .LVU13
 109:example.c     **** 		if (!c) break;
  63               		.loc 1 109 5 is_stmt 0 view .LVU14
  64 0014 00C0      		rjmp .L3
  65               	.LVL5:
  66               	.L1:
  67               	/* epilogue start */
 112:example.c     **** 	}
 113:example.c     **** }
  68               		.loc 1 113 1 view .LVU15
  69 0016 DF91      		pop r29
  70 0018 CF91      		pop r28
  71               	.LVL6:
  72               		.loc 1 113 1 view .LVU16
  73 001a 0895      		ret
  74               		.cfi_endproc
  75               	.LFE8:
  77               		.section	.text.recv_str,"ax",@progbits
  78               	.global	recv_str
  80               	recv_str:
  81               	.LVL7:
  82               	.LFB9:
 114:example.c     **** 
 115:example.c     **** // Receive a string from the USB serial port.  The string is stored
 116:example.c     **** // in the buffer and this function will not exceed the buffer size.
 117:example.c     **** // A carriage return or newline completes the string, and is not
 118:example.c     **** // stored into the buffer.
 119:example.c     **** // The return value is the number of characters received, or 255 if
 120:example.c     **** // the virtual serial connection was closed while waiting.
 121:example.c     **** //
 122:example.c     **** uint8_t recv_str(char *buf, uint8_t size)
 123:example.c     **** {
  83               		.loc 1 123 1 is_stmt 1 view -0
  84               		.cfi_startproc
  85               		.loc 1 123 1 is_stmt 0 view .LVU18
  86 0000 EF92      		push r14
  87               	.LCFI2:
  88               		.cfi_def_cfa_offset 3
  89               		.cfi_offset 14, -2
  90 0002 FF92      		push r15
  91               	.LCFI3:
  92               		.cfi_def_cfa_offset 4
  93               		.cfi_offset 15, -3
  94 0004 0F93      		push r16
  95               	.LCFI4:
  96               		.cfi_def_cfa_offset 5
  97               		.cfi_offset 16, -4
  98 0006 1F93      		push r17
  99               	.LCFI5:
 100               		.cfi_def_cfa_offset 6
 101               		.cfi_offset 17, -5
 102 0008 CF93      		push r28
 103               	.LCFI6:
 104               		.cfi_def_cfa_offset 7
 105               		.cfi_offset 28, -6
 106 000a DF93      		push r29
 107               	.LCFI7:
 108               		.cfi_def_cfa_offset 8
 109               		.cfi_offset 29, -7
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 112               	/* stack size = 6 */
 113               	.L__stack_usage = 6
 114 000c 082F      		mov r16,r24
 115 000e F92E      		mov r15,r25
 116 0010 E62E      		mov r14,r22
 124:example.c     **** 	int16_t r;
 117               		.loc 1 124 2 is_stmt 1 view .LVU19
 125:example.c     **** 	uint8_t count=0;
 118               		.loc 1 125 2 view .LVU20
 119               	.LVL8:
 126:example.c     **** 
 127:example.c     **** 	while (count < size) {
 120               		.loc 1 127 2 view .LVU21
 125:example.c     **** 	uint8_t count=0;
 121               		.loc 1 125 10 is_stmt 0 view .LVU22
 122 0012 10E0      		ldi r17,0
 123               	.LVL9:
 124               	.L5:
 125               		.loc 1 127 8 is_stmt 1 view .LVU23
 126 0014 1E15      		cp r17,r14
 127 0016 00F4      		brsh .L4
 128:example.c     **** 		r = usb_serial_getchar();
 128               		.loc 1 128 3 view .LVU24
 129               		.loc 1 128 7 is_stmt 0 view .LVU25
 130 0018 0E94 0000 		call usb_serial_getchar
 131               	.LVL10:
 132 001c 9C01      		movw r18,r24
 133               	.LVL11:
 129:example.c     **** 		if (r != -1) {
 134               		.loc 1 129 3 is_stmt 1 view .LVU26
 135               		.loc 1 129 6 is_stmt 0 view .LVU27
 136 001e 2F3F      		cpi r18,-1
 137 0020 3207      		cpc r19,r18
 138 0022 01F0      		breq .L6
 130:example.c     **** 			if (r == '\r' || r == '\n') return count;
 139               		.loc 1 130 4 is_stmt 1 view .LVU28
 140               		.loc 1 130 7 is_stmt 0 view .LVU29
 141 0024 2D30      		cpi r18,13
 142 0026 3105      		cpc r19,__zero_reg__
 143 0028 01F0      		breq .L4
 144               		.loc 1 130 18 discriminator 2 view .LVU30
 145 002a 2A30      		cpi r18,10
 146 002c 3105      		cpc r19,__zero_reg__
 147 002e 01F0      		breq .L4
 131:example.c     **** 			if (r >= ' ' && r <= '~') {
 148               		.loc 1 131 4 is_stmt 1 view .LVU31
 149               		.loc 1 131 17 is_stmt 0 view .LVU32
 150 0030 C901      		movw r24,r18
 151 0032 8097      		sbiw r24,32
 152               		.loc 1 131 7 view .LVU33
 153 0034 8F35      		cpi r24,95
 154 0036 9105      		cpc r25,__zero_reg__
 155 0038 00F4      		brsh .L5
 132:example.c     **** 				*buf++ = r;
 156               		.loc 1 132 5 is_stmt 1 view .LVU34
 157               		.loc 1 132 9 is_stmt 0 view .LVU35
 158 003a C02F      		mov r28,r16
 159 003c DF2D      		mov r29,r15
 160               	.LVL12:
 161               		.loc 1 132 12 view .LVU36
 162 003e 2993      		st Y+,r18
 163               	.LVL13:
 133:example.c     **** 				usb_serial_putchar(r);
 164               		.loc 1 133 5 is_stmt 1 view .LVU37
 165 0040 822F      		mov r24,r18
 166 0042 0E94 0000 		call usb_serial_putchar
 167               	.LVL14:
 134:example.c     **** 				count++;
 168               		.loc 1 134 5 view .LVU38
 169               		.loc 1 134 10 is_stmt 0 view .LVU39
 170 0046 1F5F      		subi r17,lo8(-(1))
 171               	.LVL15:
 132:example.c     **** 				*buf++ = r;
 172               		.loc 1 132 9 view .LVU40
 173 0048 0C2F      		mov r16,r28
 174 004a FD2E      		mov r15,r29
 175 004c 00C0      		rjmp .L5
 176               	.LVL16:
 177               	.L6:
 135:example.c     **** 			}
 136:example.c     **** 		} else {
 137:example.c     **** 			if (!usb_configured() ||
 178               		.loc 1 137 4 is_stmt 1 view .LVU41
 179               		.loc 1 137 9 is_stmt 0 view .LVU42
 180 004e 0E94 0000 		call usb_configured
 181               	.LVL17:
 182               		.loc 1 137 7 view .LVU43
 183 0052 8111      		cpse r24,__zero_reg__
 184 0054 00C0      		rjmp .L9
 185               	.L10:
 138:example.c     **** 			  !(usb_serial_get_control() & USB_SERIAL_DTR)) {
 139:example.c     **** 				// user no longer connected
 140:example.c     **** 				return 255;
 186               		.loc 1 140 12 view .LVU44
 187 0056 1FEF      		ldi r17,lo8(-1)
 188               	.LVL18:
 189               	.L4:
 141:example.c     **** 			}
 142:example.c     **** 			// just a normal timeout, keep waiting
 143:example.c     **** 		}
 144:example.c     **** 	}
 145:example.c     **** 	return count;
 146:example.c     **** }
 190               		.loc 1 146 1 view .LVU45
 191 0058 812F      		mov r24,r17
 192               	/* epilogue start */
 193 005a DF91      		pop r29
 194 005c CF91      		pop r28
 195 005e 1F91      		pop r17
 196 0060 0F91      		pop r16
 197               	.LVL19:
 198               		.loc 1 146 1 view .LVU46
 199 0062 FF90      		pop r15
 200 0064 EF90      		pop r14
 201               	.LVL20:
 202               		.loc 1 146 1 view .LVU47
 203 0066 0895      		ret
 204               	.LVL21:
 205               	.L9:
 138:example.c     **** 			  !(usb_serial_get_control() & USB_SERIAL_DTR)) {
 206               		.loc 1 138 8 discriminator 1 view .LVU48
 207 0068 0E94 0000 		call usb_serial_get_control
 208               	.LVL22:
 137:example.c     **** 			  !(usb_serial_get_control() & USB_SERIAL_DTR)) {
 209               		.loc 1 137 26 discriminator 1 view .LVU49
 210 006c 80FD      		sbrc r24,0
 211 006e 00C0      		rjmp .L5
 212 0070 00C0      		rjmp .L10
 213               		.cfi_endproc
 214               	.LFE9:
 216               		.section	.text.parse_and_execute_command,"ax",@progbits
 217               	.global	parse_and_execute_command
 219               	parse_and_execute_command:
 220               	.LVL23:
 221               	.LFB10:
 147:example.c     **** 
 148:example.c     **** // parse a user command and execute it, or print an error message
 149:example.c     **** //
 150:example.c     **** void parse_and_execute_command(const char *buf, uint8_t num)
 151:example.c     **** {
 222               		.loc 1 151 1 is_stmt 1 view -0
 223               		.cfi_startproc
 224               		.loc 1 151 1 is_stmt 0 view .LVU51
 225 0000 CF93      		push r28
 226               	.LCFI8:
 227               		.cfi_def_cfa_offset 3
 228               		.cfi_offset 28, -2
 229 0002 DF93      		push r29
 230               	.LCFI9:
 231               		.cfi_def_cfa_offset 4
 232               		.cfi_offset 29, -3
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 2 */
 236               	.L__stack_usage = 2
 237 0004 EC01      		movw r28,r24
 152:example.c     **** 	uint8_t port, pin, val;
 238               		.loc 1 152 2 is_stmt 1 view .LVU52
 153:example.c     **** 
 154:example.c     **** 	if (num < 3) {
 239               		.loc 1 154 2 view .LVU53
 155:example.c     **** 		send_str(PSTR("unrecognized format, 3 chars min req'd\r\n"));
 240               		.loc 1 155 3 is_stmt 0 view .LVU54
 241 0006 80E0      		ldi r24,lo8(__c.1863)
 242 0008 90E0      		ldi r25,hi8(__c.1863)
 243               	.LVL24:
 154:example.c     **** 		send_str(PSTR("unrecognized format, 3 chars min req'd\r\n"));
 244               		.loc 1 154 5 view .LVU55
 245 000a 6330      		cpi r22,lo8(3)
 246 000c 00F0      		brlo .L38
 156:example.c     **** 		return;
 157:example.c     **** 	}
 158:example.c     **** 	// first character is the port letter
 159:example.c     **** 	if (buf[0] >= 'A' && buf[0] <= 'F') {
 247               		.loc 1 159 2 is_stmt 1 view .LVU56
 248               		.loc 1 159 9 is_stmt 0 view .LVU57
 249 000e 8881      		ld r24,Y
 250               		.loc 1 159 20 view .LVU58
 251 0010 EFEB      		ldi r30,lo8(-65)
 252 0012 E80F      		add r30,r24
 253               		.loc 1 159 5 view .LVU59
 254 0014 E630      		cpi r30,lo8(6)
 255 0016 00F0      		brlo .L23
 160:example.c     **** 		port = buf[0] - 'A';
 161:example.c     **** 	} else if (buf[0] >= 'a' && buf[0] <= 'f') {
 256               		.loc 1 161 9 is_stmt 1 view .LVU60
 257               		.loc 1 161 27 is_stmt 0 view .LVU61
 258 0018 EFE9      		ldi r30,lo8(-97)
 259 001a E80F      		add r30,r24
 260               		.loc 1 161 12 view .LVU62
 261 001c E630      		cpi r30,lo8(6)
 262 001e 00F0      		brlo .L23
 162:example.c     **** 		port = buf[0] - 'a';
 163:example.c     **** 	} else {
 164:example.c     **** 		send_str(PSTR("Unknown port \""));
 263               		.loc 1 164 3 is_stmt 1 view .LVU63
 264               	.LBB8:
 265               		.loc 1 164 12 view .LVU64
 266               		.loc 1 164 12 view .LVU65
 267               	.LBE8:
 268               		.loc 1 164 3 is_stmt 0 view .LVU66
 269 0020 80E0      		ldi r24,lo8(__c.1865)
 270 0022 90E0      		ldi r25,hi8(__c.1865)
 271 0024 0E94 0000 		call send_str
 272               	.LVL25:
 165:example.c     **** 		usb_serial_putchar(buf[0]);
 273               		.loc 1 165 3 is_stmt 1 view .LVU67
 274 0028 8881      		ld r24,Y
 275 002a 0E94 0000 		call usb_serial_putchar
 276               	.LVL26:
 166:example.c     **** 		send_str(PSTR("\", must be A - F\r\n"));
 277               		.loc 1 166 3 view .LVU68
 278               	.LBB9:
 279               		.loc 1 166 12 view .LVU69
 280               		.loc 1 166 12 view .LVU70
 281               	.LBE9:
 282               		.loc 1 166 3 is_stmt 0 view .LVU71
 283 002e 80E0      		ldi r24,lo8(__c.1867)
 284 0030 90E0      		ldi r25,hi8(__c.1867)
 285               	.L38:
 286               	/* epilogue start */
 167:example.c     **** 		return;
 168:example.c     **** 	}
 169:example.c     **** 	// second character is the pin number
 170:example.c     **** 	if (buf[1] >= '0' && buf[1] <= '7') {
 171:example.c     **** 		pin = buf[1] - '0';
 172:example.c     **** 	} else {
 173:example.c     **** 		send_str(PSTR("Unknown pin \""));
 174:example.c     **** 		usb_serial_putchar(buf[0]);
 175:example.c     **** 		send_str(PSTR("\", must be 0 to 7\r\n"));
 176:example.c     **** 		return;
 177:example.c     **** 	}
 178:example.c     **** 	// if the third character is a question mark, read the pin
 179:example.c     **** 	if (buf[2] == '?') {
 180:example.c     **** 		// make the pin an input
 181:example.c     **** 		*(uint8_t *)(0x21 + port * 3) &= ~(1 << pin);
 182:example.c     **** 		// read the pin
 183:example.c     **** 		val = *(uint8_t *)(0x20 + port * 3) & (1 << pin);
 184:example.c     **** 		usb_serial_putchar(val ? '1' : '0');
 185:example.c     **** 		send_str(PSTR("\r\n"));
 186:example.c     **** 		return;
 187:example.c     **** 	}
 188:example.c     **** 	// if the third character is an equals sign, write the pin
 189:example.c     **** 	if (num >= 4 && buf[2] == '=') {
 190:example.c     **** 		if (buf[3] == '0') {
 191:example.c     **** 			// make the pin an output
 192:example.c     **** 			*(uint8_t *)(0x21 + port * 3) |= (1 << pin);
 193:example.c     **** 			// drive it low
 194:example.c     **** 			*(uint8_t *)(0x22 + port * 3) &= ~(1 << pin);
 195:example.c     **** 			return;
 196:example.c     **** 		} else if (buf[3] == '1') {
 197:example.c     **** 			// make the pin an output
 198:example.c     **** 			*(uint8_t *)(0x21 + port * 3) |= (1 << pin);
 199:example.c     **** 			// drive it high
 200:example.c     **** 			*(uint8_t *)(0x22 + port * 3) |= (1 << pin);
 201:example.c     **** 			return;
 202:example.c     **** 		} else {
 203:example.c     **** 			send_str(PSTR("Unknown value \""));
 204:example.c     **** 			usb_serial_putchar(buf[3]);
 205:example.c     **** 			send_str(PSTR("\", must be 0 or 1\r\n"));
 206:example.c     **** 			return;
 207:example.c     **** 		}
 208:example.c     **** 	}
 209:example.c     **** 	// otherwise, error message
 210:example.c     **** 	send_str(PSTR("Unknown command \""));
 211:example.c     **** 	usb_serial_putchar(buf[0]);
 212:example.c     **** 	send_str(PSTR("\", must be ? or =\r\n"));
 213:example.c     **** }
 287               		.loc 1 213 1 view .LVU72
 288 0032 DF91      		pop r29
 289 0034 CF91      		pop r28
 290               	.LVL27:
 212:example.c     **** }
 291               		.loc 1 212 2 view .LVU73
 292 0036 0C94 0000 		jmp send_str
 293               	.LVL28:
 294               	.L23:
 170:example.c     **** 		pin = buf[1] - '0';
 295               		.loc 1 170 2 is_stmt 1 view .LVU74
 170:example.c     **** 		pin = buf[1] - '0';
 296               		.loc 1 170 20 is_stmt 0 view .LVU75
 297 003a 8981      		ldd r24,Y+1
 298 003c 8053      		subi r24,lo8(-(-48))
 170:example.c     **** 		pin = buf[1] - '0';
 299               		.loc 1 170 5 view .LVU76
 300 003e 8830      		cpi r24,lo8(8)
 301 0040 00F4      		brsh .L24
 171:example.c     **** 	} else {
 302               		.loc 1 171 3 is_stmt 1 view .LVU77
 303               	.LVL29:
 179:example.c     **** 		// make the pin an input
 304               		.loc 1 179 2 view .LVU78
 179:example.c     **** 		// make the pin an input
 305               		.loc 1 179 9 is_stmt 0 view .LVU79
 306 0042 9A81      		ldd r25,Y+2
 179:example.c     **** 		// make the pin an input
 307               		.loc 1 179 5 view .LVU80
 308 0044 9F33      		cpi r25,lo8(63)
 309 0046 01F4      		brne .L36
 181:example.c     **** 		// read the pin
 310               		.loc 1 181 3 is_stmt 1 view .LVU81
 181:example.c     **** 		// read the pin
 311               		.loc 1 181 33 is_stmt 0 view .LVU82
 312 0048 43E0      		ldi r20,lo8(3)
 313 004a E49F      		mul r30,r20
 314 004c F001      		movw r30,r0
 315 004e 1124      		clr __zero_reg__
 316               	.LVL30:
 181:example.c     **** 		// read the pin
 317               		.loc 1 181 40 view .LVU83
 318 0050 21E0      		ldi r18,lo8(1)
 319 0052 30E0      		ldi r19,0
 320 0054 A901      		movw r20,r18
 321 0056 00C0      		rjmp 2f
 322               		1:
 323 0058 440F      		lsl r20
 324 005a 551F      		rol r21
 325               		2:
 326 005c 8A95      		dec r24
 327 005e 02F4      		brpl 1b
 328 0060 CA01      		movw r24,r20
 329               	.LVL31:
 181:example.c     **** 		// read the pin
 330               		.loc 1 181 33 view .LVU84
 331 0062 242F      		mov r18,r20
 332 0064 2095      		com r18
 333 0066 91A1      		ldd r25,Z+33
 334 0068 9223      		and r25,r18
 335 006a 91A3      		std Z+33,r25
 336               	.LVL32:
 183:example.c     **** 		usb_serial_putchar(val ? '1' : '0');
 337               		.loc 1 183 3 is_stmt 1 view .LVU85
 184:example.c     **** 		send_str(PSTR("\r\n"));
 338               		.loc 1 184 3 view .LVU86
 183:example.c     **** 		usb_serial_putchar(val ? '1' : '0');
 339               		.loc 1 183 39 is_stmt 0 view .LVU87
 340 006c 90A1      		ldd r25,Z+32
 341 006e 8923      		and r24,r25
 184:example.c     **** 		send_str(PSTR("\r\n"));
 342               		.loc 1 184 3 view .LVU88
 343 0070 01F4      		brne .L32
 344 0072 80E3      		ldi r24,lo8(48)
 345               	.L27:
 184:example.c     **** 		send_str(PSTR("\r\n"));
 346               		.loc 1 184 3 discriminator 4 view .LVU89
 347 0074 0E94 0000 		call usb_serial_putchar
 348               	.LVL33:
 185:example.c     **** 		return;
 349               		.loc 1 185 3 is_stmt 1 discriminator 4 view .LVU90
 350               	.LBB10:
 185:example.c     **** 		return;
 351               		.loc 1 185 12 discriminator 4 view .LVU91
 185:example.c     **** 		return;
 352               		.loc 1 185 12 discriminator 4 view .LVU92
 353               	.LBE10:
 185:example.c     **** 		return;
 354               		.loc 1 185 3 is_stmt 0 discriminator 4 view .LVU93
 355 0078 80E0      		ldi r24,lo8(__c.1873)
 356 007a 90E0      		ldi r25,hi8(__c.1873)
 357 007c 00C0      		rjmp .L38
 358               	.LVL34:
 359               	.L24:
 173:example.c     **** 		usb_serial_putchar(buf[0]);
 360               		.loc 1 173 3 is_stmt 1 view .LVU94
 361               	.LBB11:
 173:example.c     **** 		usb_serial_putchar(buf[0]);
 362               		.loc 1 173 12 view .LVU95
 173:example.c     **** 		usb_serial_putchar(buf[0]);
 363               		.loc 1 173 12 view .LVU96
 364               	.LBE11:
 173:example.c     **** 		usb_serial_putchar(buf[0]);
 365               		.loc 1 173 3 is_stmt 0 view .LVU97
 366 007e 80E0      		ldi r24,lo8(__c.1869)
 367 0080 90E0      		ldi r25,hi8(__c.1869)
 368 0082 0E94 0000 		call send_str
 369               	.LVL35:
 174:example.c     **** 		send_str(PSTR("\", must be 0 to 7\r\n"));
 370               		.loc 1 174 3 is_stmt 1 view .LVU98
 371 0086 8881      		ld r24,Y
 372 0088 0E94 0000 		call usb_serial_putchar
 373               	.LVL36:
 175:example.c     **** 		return;
 374               		.loc 1 175 3 view .LVU99
 375               	.LBB12:
 175:example.c     **** 		return;
 376               		.loc 1 175 12 view .LVU100
 175:example.c     **** 		return;
 377               		.loc 1 175 12 view .LVU101
 378               	.LBE12:
 175:example.c     **** 		return;
 379               		.loc 1 175 3 is_stmt 0 view .LVU102
 380 008c 80E0      		ldi r24,lo8(__c.1871)
 381 008e 90E0      		ldi r25,hi8(__c.1871)
 382 0090 00C0      		rjmp .L38
 383               	.LVL37:
 384               	.L32:
 184:example.c     **** 		send_str(PSTR("\r\n"));
 385               		.loc 1 184 3 view .LVU103
 386 0092 81E3      		ldi r24,lo8(49)
 387 0094 00C0      		rjmp .L27
 388               	.LVL38:
 389               	.L36:
 189:example.c     **** 		if (buf[3] == '0') {
 390               		.loc 1 189 2 is_stmt 1 view .LVU104
 189:example.c     **** 		if (buf[3] == '0') {
 391               		.loc 1 189 5 is_stmt 0 view .LVU105
 392 0096 6330      		cpi r22,lo8(3)
 393 0098 01F0      		breq .L28
 189:example.c     **** 		if (buf[3] == '0') {
 394               		.loc 1 189 15 discriminator 1 view .LVU106
 395 009a 9D33      		cpi r25,lo8(61)
 396 009c 01F4      		brne .L28
 190:example.c     **** 			// make the pin an output
 397               		.loc 1 190 3 is_stmt 1 view .LVU107
 190:example.c     **** 			// make the pin an output
 398               		.loc 1 190 10 is_stmt 0 view .LVU108
 399 009e 9B81      		ldd r25,Y+3
 190:example.c     **** 			// make the pin an output
 400               		.loc 1 190 6 view .LVU109
 401 00a0 9033      		cpi r25,lo8(48)
 402 00a2 01F4      		brne .L29
 192:example.c     **** 			// drive it low
 403               		.loc 1 192 4 is_stmt 1 view .LVU110
 192:example.c     **** 			// drive it low
 404               		.loc 1 192 34 is_stmt 0 view .LVU111
 405 00a4 53E0      		ldi r21,lo8(3)
 406 00a6 E59F      		mul r30,r21
 407 00a8 F001      		movw r30,r0
 408 00aa 1124      		clr __zero_reg__
 409               	.LVL39:
 192:example.c     **** 			// drive it low
 410               		.loc 1 192 40 view .LVU112
 411 00ac 21E0      		ldi r18,lo8(1)
 412 00ae 30E0      		ldi r19,0
 413 00b0 A901      		movw r20,r18
 414 00b2 00C0      		rjmp 2f
 415               		1:
 416 00b4 440F      		lsl r20
 417 00b6 551F      		rol r21
 418               		2:
 419 00b8 8A95      		dec r24
 420 00ba 02F4      		brpl 1b
 421 00bc CA01      		movw r24,r20
 422               	.LVL40:
 192:example.c     **** 			// drive it low
 423               		.loc 1 192 34 view .LVU113
 424 00be 91A1      		ldd r25,Z+33
 425 00c0 982B      		or r25,r24
 426 00c2 91A3      		std Z+33,r25
 427               	.LVL41:
 194:example.c     **** 			return;
 428               		.loc 1 194 4 is_stmt 1 view .LVU114
 194:example.c     **** 			return;
 429               		.loc 1 194 34 is_stmt 0 view .LVU115
 430 00c4 8095      		com r24
 431 00c6 92A1      		ldd r25,Z+34
 432 00c8 8923      		and r24,r25
 433               	.L37:
 200:example.c     **** 			return;
 434               		.loc 1 200 34 view .LVU116
 435 00ca 82A3      		std Z+34,r24
 201:example.c     **** 		} else {
 436               		.loc 1 201 4 is_stmt 1 view .LVU117
 437               	/* epilogue start */
 438               		.loc 1 213 1 is_stmt 0 view .LVU118
 439 00cc DF91      		pop r29
 440 00ce CF91      		pop r28
 441               	.LVL42:
 442               		.loc 1 213 1 view .LVU119
 443 00d0 0895      		ret
 444               	.LVL43:
 445               	.L29:
 196:example.c     **** 			// make the pin an output
 446               		.loc 1 196 10 is_stmt 1 view .LVU120
 196:example.c     **** 			// make the pin an output
 447               		.loc 1 196 13 is_stmt 0 view .LVU121
 448 00d2 9133      		cpi r25,lo8(49)
 449 00d4 01F4      		brne .L31
 198:example.c     **** 			// drive it high
 450               		.loc 1 198 4 is_stmt 1 view .LVU122
 198:example.c     **** 			// drive it high
 451               		.loc 1 198 34 is_stmt 0 view .LVU123
 452 00d6 53E0      		ldi r21,lo8(3)
 453 00d8 E59F      		mul r30,r21
 454 00da F001      		movw r30,r0
 455 00dc 1124      		clr __zero_reg__
 456               	.LVL44:
 198:example.c     **** 			// drive it high
 457               		.loc 1 198 40 view .LVU124
 458 00de 21E0      		ldi r18,lo8(1)
 459 00e0 30E0      		ldi r19,0
 460 00e2 A901      		movw r20,r18
 461 00e4 00C0      		rjmp 2f
 462               		1:
 463 00e6 440F      		lsl r20
 464 00e8 551F      		rol r21
 465               		2:
 466 00ea 8A95      		dec r24
 467 00ec 02F4      		brpl 1b
 468 00ee CA01      		movw r24,r20
 469               	.LVL45:
 198:example.c     **** 			// drive it high
 470               		.loc 1 198 34 view .LVU125
 471 00f0 91A1      		ldd r25,Z+33
 472 00f2 982B      		or r25,r24
 473 00f4 91A3      		std Z+33,r25
 474               	.LVL46:
 200:example.c     **** 			return;
 475               		.loc 1 200 4 is_stmt 1 view .LVU126
 200:example.c     **** 			return;
 476               		.loc 1 200 34 is_stmt 0 view .LVU127
 477 00f6 92A1      		ldd r25,Z+34
 478 00f8 892B      		or r24,r25
 479 00fa 00C0      		rjmp .L37
 480               	.LVL47:
 481               	.L31:
 203:example.c     **** 			usb_serial_putchar(buf[3]);
 482               		.loc 1 203 4 is_stmt 1 view .LVU128
 483               	.LBB13:
 203:example.c     **** 			usb_serial_putchar(buf[3]);
 484               		.loc 1 203 13 view .LVU129
 203:example.c     **** 			usb_serial_putchar(buf[3]);
 485               		.loc 1 203 13 view .LVU130
 486               	.LBE13:
 203:example.c     **** 			usb_serial_putchar(buf[3]);
 487               		.loc 1 203 4 is_stmt 0 view .LVU131
 488 00fc 80E0      		ldi r24,lo8(__c.1875)
 489 00fe 90E0      		ldi r25,hi8(__c.1875)
 490               	.LVL48:
 203:example.c     **** 			usb_serial_putchar(buf[3]);
 491               		.loc 1 203 4 view .LVU132
 492 0100 0E94 0000 		call send_str
 493               	.LVL49:
 204:example.c     **** 			send_str(PSTR("\", must be 0 or 1\r\n"));
 494               		.loc 1 204 4 is_stmt 1 view .LVU133
 495 0104 8B81      		ldd r24,Y+3
 496 0106 0E94 0000 		call usb_serial_putchar
 497               	.LVL50:
 205:example.c     **** 			return;
 498               		.loc 1 205 4 view .LVU134
 499               	.LBB14:
 205:example.c     **** 			return;
 500               		.loc 1 205 13 view .LVU135
 205:example.c     **** 			return;
 501               		.loc 1 205 13 view .LVU136
 502               	.LBE14:
 205:example.c     **** 			return;
 503               		.loc 1 205 4 is_stmt 0 view .LVU137
 504 010a 80E0      		ldi r24,lo8(__c.1877)
 505 010c 90E0      		ldi r25,hi8(__c.1877)
 506 010e 00C0      		rjmp .L38
 507               	.LVL51:
 508               	.L28:
 210:example.c     **** 	usb_serial_putchar(buf[0]);
 509               		.loc 1 210 2 is_stmt 1 view .LVU138
 510               	.LBB15:
 210:example.c     **** 	usb_serial_putchar(buf[0]);
 511               		.loc 1 210 11 view .LVU139
 210:example.c     **** 	usb_serial_putchar(buf[0]);
 512               		.loc 1 210 11 view .LVU140
 513               	.LBE15:
 210:example.c     **** 	usb_serial_putchar(buf[0]);
 514               		.loc 1 210 2 is_stmt 0 view .LVU141
 515 0110 80E0      		ldi r24,lo8(__c.1879)
 516 0112 90E0      		ldi r25,hi8(__c.1879)
 517               	.LVL52:
 210:example.c     **** 	usb_serial_putchar(buf[0]);
 518               		.loc 1 210 2 view .LVU142
 519 0114 0E94 0000 		call send_str
 520               	.LVL53:
 211:example.c     **** 	send_str(PSTR("\", must be ? or =\r\n"));
 521               		.loc 1 211 2 is_stmt 1 view .LVU143
 522 0118 8881      		ld r24,Y
 523 011a 0E94 0000 		call usb_serial_putchar
 524               	.LVL54:
 212:example.c     **** }
 525               		.loc 1 212 2 view .LVU144
 526               	.LBB16:
 212:example.c     **** }
 527               		.loc 1 212 11 view .LVU145
 212:example.c     **** }
 528               		.loc 1 212 11 view .LVU146
 529               	.LBE16:
 212:example.c     **** }
 530               		.loc 1 212 2 is_stmt 0 view .LVU147
 531 011e 80E0      		ldi r24,lo8(__c.1881)
 532 0120 90E0      		ldi r25,hi8(__c.1881)
 533 0122 00C0      		rjmp .L38
 534               		.cfi_endproc
 535               	.LFE10:
 537               		.section	.text.startup.main,"ax",@progbits
 538               	.global	main
 540               	main:
 541               	.LFB7:
  55:example.c     **** 	char buf[32];
 542               		.loc 1 55 1 is_stmt 1 view -0
 543               		.cfi_startproc
 544 0000 CDB7      		in r28,__SP_L__
 545 0002 DEB7      		in r29,__SP_H__
 546               	.LCFI10:
 547               		.cfi_def_cfa_register 28
 548 0004 A097      		sbiw r28,32
 549               	.LCFI11:
 550               		.cfi_def_cfa_offset 34
 551 0006 0FB6      		in __tmp_reg__,__SREG__
 552 0008 F894      		cli
 553 000a DEBF      		out __SP_H__,r29
 554 000c 0FBE      		out __SREG__,__tmp_reg__
 555 000e CDBF      		out __SP_L__,r28
 556               	/* prologue: function */
 557               	/* frame size = 32 */
 558               	/* stack size = 32 */
 559               	.L__stack_usage = 32
  56:example.c     **** 	uint8_t n;
 560               		.loc 1 56 2 view .LVU149
  57:example.c     **** 
 561               		.loc 1 57 2 view .LVU150
  60:example.c     **** 	LED_CONFIG;
 562               		.loc 1 60 2 view .LVU151
 563 0010 80E8      		ldi r24,lo8(-128)
 564 0012 8093 6100 		sts 97,r24
 565 0016 1092 6100 		sts 97,__zero_reg__
  61:example.c     **** 	LED_ON;
 566               		.loc 1 61 2 view .LVU152
 567 001a 569A      		sbi 0xa,6
  62:example.c     **** 
 568               		.loc 1 62 2 view .LVU153
 569 001c 5E9A      		sbi 0xb,6
  68:example.c     **** 	while (!usb_configured()) /* wait */ ;
 570               		.loc 1 68 2 view .LVU154
 571 001e 0E94 0000 		call usb_init
 572               	.LVL55:
  69:example.c     **** 	_delay_ms(1000);
 573               		.loc 1 69 2 view .LVU155
 574               	.L40:
  69:example.c     **** 	_delay_ms(1000);
 575               		.loc 1 69 39 discriminator 1 view .LVU156
  69:example.c     **** 	_delay_ms(1000);
 576               		.loc 1 69 8 discriminator 1 view .LVU157
  69:example.c     **** 	_delay_ms(1000);
 577               		.loc 1 69 10 is_stmt 0 discriminator 1 view .LVU158
 578 0022 0E94 0000 		call usb_configured
 579               	.LVL56:
  69:example.c     **** 	_delay_ms(1000);
 580               		.loc 1 69 8 discriminator 1 view .LVU159
 581 0026 8823      		tst r24
 582 0028 01F0      		breq .L40
  70:example.c     **** 
 583               		.loc 1 70 2 is_stmt 1 view .LVU160
 584               	.LVL57:
 585               	.LBB17:
 586               	.LBI17:
 587               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 588               		.loc 2 166 1 view .LVU161
 589               	.LBB18:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 590               		.loc 2 168 2 view .LVU162
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 591               		.loc 2 172 2 view .LVU163
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 592               		.loc 2 173 2 view .LVU164
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 593               		.loc 2 174 2 view .LVU165
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 594               		.loc 2 184 3 view .LVU166
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 595               		.loc 2 187 2 view .LVU167
 596 002a 2FEF      		ldi r18,lo8(3199999)
 597 002c 83ED      		ldi r24,hi8(3199999)
 598 002e 90E3      		ldi r25,hlo8(3199999)
 599 0030 2150      	1:	subi r18,1
 600 0032 8040      		sbci r24,0
 601 0034 9040      		sbci r25,0
 602 0036 01F4      		brne 1b
 603 0038 00C0      		rjmp .
 604 003a 0000      		nop
 605               	.LVL58:
 606               	.L41:
 607               		.loc 2 187 2 is_stmt 0 view .LVU168
 608               	.LBE18:
 609               	.LBE17:
  75:example.c     **** 
 610               		.loc 1 75 67 is_stmt 1 discriminator 1 view .LVU169
  75:example.c     **** 
 611               		.loc 1 75 9 discriminator 1 view .LVU170
  75:example.c     **** 
 612               		.loc 1 75 12 is_stmt 0 discriminator 1 view .LVU171
 613 003c 0E94 0000 		call usb_serial_get_control
 614               	.LVL59:
  75:example.c     **** 
 615               		.loc 1 75 9 discriminator 1 view .LVU172
 616 0040 80FF      		sbrs r24,0
 617 0042 00C0      		rjmp .L41
  80:example.c     **** 
 618               		.loc 1 80 3 is_stmt 1 view .LVU173
 619 0044 0E94 0000 		call usb_serial_flush_input
 620               	.LVL60:
  83:example.c     **** 			"Simple Pin Control Shell\r\n\r\n"
 621               		.loc 1 83 3 view .LVU174
 622               	.LBB19:
  83:example.c     **** 			"Simple Pin Control Shell\r\n\r\n"
 623               		.loc 1 83 12 view .LVU175
  83:example.c     **** 			"Simple Pin Control Shell\r\n\r\n"
 624               		.loc 1 83 12 view .LVU176
 625               	.LBE19:
  83:example.c     **** 			"Simple Pin Control Shell\r\n\r\n"
 626               		.loc 1 83 3 is_stmt 0 view .LVU177
 627 0048 80E0      		ldi r24,lo8(__c.1829)
 628 004a 90E0      		ldi r25,hi8(__c.1829)
 629 004c 0E94 0000 		call send_str
 630               	.LVL61:
 631               	.L43:
  91:example.c     **** 			send_str(PSTR("> "));
 632               		.loc 1 91 3 is_stmt 1 view .LVU178
  92:example.c     **** 			n = recv_str(buf, sizeof(buf));
 633               		.loc 1 92 4 view .LVU179
 634               	.LBB20:
  92:example.c     **** 			n = recv_str(buf, sizeof(buf));
 635               		.loc 1 92 13 view .LVU180
  92:example.c     **** 			n = recv_str(buf, sizeof(buf));
 636               		.loc 1 92 13 view .LVU181
 637               	.LBE20:
  92:example.c     **** 			n = recv_str(buf, sizeof(buf));
 638               		.loc 1 92 4 is_stmt 0 view .LVU182
 639 0050 80E0      		ldi r24,lo8(__c.1831)
 640 0052 90E0      		ldi r25,hi8(__c.1831)
 641 0054 0E94 0000 		call send_str
 642               	.LVL62:
  93:example.c     **** 			if (n == 255) break;
 643               		.loc 1 93 4 is_stmt 1 view .LVU183
  93:example.c     **** 			if (n == 255) break;
 644               		.loc 1 93 8 is_stmt 0 view .LVU184
 645 0058 60E2      		ldi r22,lo8(32)
 646 005a CE01      		movw r24,r28
 647 005c 0196      		adiw r24,1
 648 005e 0E94 0000 		call recv_str
 649               	.LVL63:
 650 0062 182F      		mov r17,r24
 651               	.LVL64:
  94:example.c     **** 			send_str(PSTR("\r\n"));
 652               		.loc 1 94 4 is_stmt 1 view .LVU185
  94:example.c     **** 			send_str(PSTR("\r\n"));
 653               		.loc 1 94 7 is_stmt 0 view .LVU186
 654 0064 8F3F      		cpi r24,lo8(-1)
 655 0066 01F0      		breq .L41
  95:example.c     **** 			parse_and_execute_command(buf, n);
 656               		.loc 1 95 4 is_stmt 1 view .LVU187
 657               	.LBB21:
  95:example.c     **** 			parse_and_execute_command(buf, n);
 658               		.loc 1 95 13 view .LVU188
  95:example.c     **** 			parse_and_execute_command(buf, n);
 659               		.loc 1 95 13 view .LVU189
 660               	.LBE21:
  95:example.c     **** 			parse_and_execute_command(buf, n);
 661               		.loc 1 95 4 is_stmt 0 view .LVU190
 662 0068 80E0      		ldi r24,lo8(__c.1834)
 663 006a 90E0      		ldi r25,hi8(__c.1834)
 664 006c 0E94 0000 		call send_str
 665               	.LVL65:
  96:example.c     **** 		}
 666               		.loc 1 96 4 is_stmt 1 view .LVU191
 667 0070 612F      		mov r22,r17
 668 0072 CE01      		movw r24,r28
 669 0074 0196      		adiw r24,1
 670 0076 0E94 0000 		call parse_and_execute_command
 671               	.LVL66:
  91:example.c     **** 			send_str(PSTR("> "));
 672               		.loc 1 91 9 view .LVU192
  92:example.c     **** 			n = recv_str(buf, sizeof(buf));
 673               		.loc 1 92 4 is_stmt 0 view .LVU193
 674 007a 00C0      		rjmp .L43
 675               		.cfi_endproc
 676               	.LFE7:
 678               		.section	.progmem.data,"a",@progbits
 681               	__c.1881:
 682 0000 222C 206D 		.string	"\", must be ? or =\r\n"
 682      7573 7420 
 682      6265 203F 
 682      206F 7220 
 682      3D0D 0A00 
 685               	__c.1879:
 686 0014 556E 6B6E 		.string	"Unknown command \""
 686      6F77 6E20 
 686      636F 6D6D 
 686      616E 6420 
 686      2200 
 689               	__c.1877:
 690 0026 222C 206D 		.string	"\", must be 0 or 1\r\n"
 690      7573 7420 
 690      6265 2030 
 690      206F 7220 
 690      310D 0A00 
 693               	__c.1875:
 694 003a 556E 6B6E 		.string	"Unknown value \""
 694      6F77 6E20 
 694      7661 6C75 
 694      6520 2200 
 697               	__c.1873:
 698 004a 0D0A 00   		.string	"\r\n"
 701               	__c.1871:
 702 004d 222C 206D 		.string	"\", must be 0 to 7\r\n"
 702      7573 7420 
 702      6265 2030 
 702      2074 6F20 
 702      370D 0A00 
 705               	__c.1869:
 706 0061 556E 6B6E 		.string	"Unknown pin \""
 706      6F77 6E20 
 706      7069 6E20 
 706      2200 
 709               	__c.1867:
 710 006f 222C 206D 		.string	"\", must be A - F\r\n"
 710      7573 7420 
 710      6265 2041 
 710      202D 2046 
 710      0D0A 00
 713               	__c.1865:
 714 0082 556E 6B6E 		.string	"Unknown port \""
 714      6F77 6E20 
 714      706F 7274 
 714      2022 00
 717               	__c.1863:
 718 0091 756E 7265 		.string	"unrecognized format, 3 chars min req'd\r\n"
 718      636F 676E 
 718      697A 6564 
 718      2066 6F72 
 718      6D61 742C 
 721               	__c.1834:
 722 00ba 0D0A 00   		.string	"\r\n"
 725               	__c.1831:
 726 00bd 3E20 00   		.string	"> "
 729               	__c.1829:
 730 00c0 0D0A 5465 		.string	"\r\nTeensy USB Serial Example, Simple Pin Control Shell\r\n\r\nExample Commands\r\n  B0? 
 730      656E 7379 
 730      2055 5342 
 730      2053 6572 
 730      6961 6C20 
 731               		.text
 732               	.Letext0:
 733               		.file 3 "/usr/avr/include/stdint.h"
 734               		.file 4 "usb_serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 example.c
     /tmp/ccpZy1IW.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccpZy1IW.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccpZy1IW.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccpZy1IW.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccpZy1IW.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccpZy1IW.s:13     .text.send_str:0000000000000000 send_str
     /tmp/ccpZy1IW.s:80     .text.recv_str:0000000000000000 recv_str
     /tmp/ccpZy1IW.s:219    .text.parse_and_execute_command:0000000000000000 parse_and_execute_command
     /tmp/ccpZy1IW.s:717    .progmem.data:0000000000000091 __c.1863
     /tmp/ccpZy1IW.s:713    .progmem.data:0000000000000082 __c.1865
     /tmp/ccpZy1IW.s:709    .progmem.data:000000000000006f __c.1867
     /tmp/ccpZy1IW.s:697    .progmem.data:000000000000004a __c.1873
     /tmp/ccpZy1IW.s:705    .progmem.data:0000000000000061 __c.1869
     /tmp/ccpZy1IW.s:701    .progmem.data:000000000000004d __c.1871
     /tmp/ccpZy1IW.s:693    .progmem.data:000000000000003a __c.1875
     /tmp/ccpZy1IW.s:689    .progmem.data:0000000000000026 __c.1877
     /tmp/ccpZy1IW.s:685    .progmem.data:0000000000000014 __c.1879
     /tmp/ccpZy1IW.s:681    .progmem.data:0000000000000000 __c.1881
     /tmp/ccpZy1IW.s:540    .text.startup.main:0000000000000000 main
     /tmp/ccpZy1IW.s:729    .progmem.data:00000000000000c0 __c.1829
     /tmp/ccpZy1IW.s:725    .progmem.data:00000000000000bd __c.1831
     /tmp/ccpZy1IW.s:721    .progmem.data:00000000000000ba __c.1834

UNDEFINED SYMBOLS
usb_serial_putchar
usb_serial_getchar
usb_configured
usb_serial_get_control
usb_init
usb_serial_flush_input
